<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gusen Platformer Game</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Arial', sans-serif;
        }

        #gameContainer {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }

        canvas {
            border: 3px solid #333;
            display: block;
            background: #87ceeb;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            image-rendering: -moz-crisp-edges;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        #controls {
            margin-top: 20px;
            padding: 15px;
            background: #f0f0f0;
            border-radius: 5px;
            text-align: center;
        }

        h1 {
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            margin-bottom: 20px;
        }

        .info {
            color: #333;
            margin: 5px 0;
        }

        .key {
            display: inline-block;
            padding: 5px 10px;
            background: #667eea;
            color: white;
            border-radius: 3px;
            margin: 0 3px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>üéÆ Gusen Platformer Game üéÆ</h1>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="controls">
            <div class="info">
                <strong>Controls:</strong>
                <span class="key">‚Üê</span>
                <span class="key">‚Üí</span>
                to move,
                <span class="key">‚Üë</span>
                <span class="key">W</span>
                <span class="key">Space</span>
                to jump
            </div>
            <div class="info">
                <strong>Goal:</strong> Jump across platforms and meet other characters!
            </div>
            <div class="info" id="score">Score: 0</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Disable image smoothing for crisp pixel art
        ctx.imageSmoothingEnabled = false;
        ctx.mozImageSmoothingEnabled = false;
        ctx.webkitImageSmoothingEnabled = false;
        ctx.msImageSmoothingEnabled = false;

        // Game state
        const game = {
            score: 0,
            frame: 0,
            keys: {},
            characters: [],
            player: null,
            assetsLoaded: 0,
            totalAssets: 0,
            gameStarted: false,
            gravity: 0.4,
            platforms: [],
            camera: {
                x: 0,
                y: 0
            },
            worldWidth: 6400,  // Much longer world for extended sidescrolling
            worldHeight: 600
        };

        // Platform class
        class Platform {
            constructor(x, y, width, height, color = '#8B4513') {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.color = color;
            }

            draw(cameraX, cameraY) {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - cameraX, this.y - cameraY, this.width, this.height);
                // Add some detail
                ctx.strokeStyle = '#654321';
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x - cameraX, this.y - cameraY, this.width, this.height);
            }

            checkCollision(character) {
                return character.x < this.x + this.width &&
                       character.x + character.width > this.x &&
                       character.y < this.y + this.height &&
                       character.y + character.height > this.y;
            }
        }

        // Sprite class to handle 2-frame directional animations
        // Frame 0 (top half) = Left movement
        // Frame 1 (bottom half) = Right movement
        class Character {
            constructor(imagePath, x, y, isPlayer = false) {
                this.x = x;
                this.y = y;
                this.scale = 4; // Scale up the tiny sprites
                this.width = 64; // Will be adjusted when image loads
                this.height = 64; // Will be adjusted when image loads
                this.velocityX = 0;
                this.velocityY = 0;
                this.speed = isPlayer ? 3 : 1.5;
                this.jumpPower = isPlayer ? -9 : -8;
                this.isPlayer = isPlayer;
                this.onGround = false;
                this.image = new Image();
                this.image.src = imagePath;
                this.loaded = false;
                this.currentFrame = 1; // Start facing right
                this.facingRight = true; // Track which direction we're facing
                this.name = imagePath.replace('.png', '');

                // Movement for NPCs
                if (!isPlayer) {
                    this.moveDirection = Math.random() > 0.5 ? 1 : -1;
                    this.jumpTimer = Math.floor(Math.random() * 60) + 30;
                    // Set initial frame based on initial direction
                    this.facingRight = this.moveDirection > 0;
                    this.currentFrame = this.facingRight ? 1 : 0;
                }

                game.totalAssets++;

                this.image.onload = () => {
                    this.loaded = true;
                    game.assetsLoaded++;
                    // Image is split horizontally: top half is frame 0, bottom half is frame 1
                    this.frameHeight = this.image.height / 2;
                    this.frameWidth = this.image.width;
                    // Adjust character size based on actual sprite size
                    this.width = this.frameWidth * this.scale;
                    this.height = this.frameHeight * this.scale;
                    console.log(`Loaded ${imagePath}: ${this.frameWidth}x${this.frameHeight} (scaled to ${this.width}x${this.height})`);

                    if (game.assetsLoaded === game.totalAssets) {
                        console.log('All assets loaded!');
                        game.gameStarted = true;
                    }
                };

                this.image.onerror = () => {
                    console.error(`Failed to load image: ${imagePath}`);
                    game.assetsLoaded++;
                    if (game.assetsLoaded === game.totalAssets) {
                        game.gameStarted = true;
                    }
                };
            }

            update() {
                // Apply gravity
                this.velocityY += game.gravity;

                if (this.isPlayer) {
                    // Player horizontal movement
                    this.velocityX = 0;

                    if (game.keys['ArrowLeft'] || game.keys['a']) {
                        this.velocityX = -this.speed;
                        this.facingRight = false;
                        this.currentFrame = 0; // Top frame for left movement
                    }
                    if (game.keys['ArrowRight'] || game.keys['d']) {
                        this.velocityX = this.speed;
                        this.facingRight = true;
                        this.currentFrame = 1; // Bottom frame for right movement
                    }

                    // Jump
                    if ((game.keys['ArrowUp'] || game.keys['w'] || game.keys[' ']) && this.onGround) {
                        this.velocityY = this.jumpPower;
                        this.onGround = false;
                    }
                } else {
                    // NPC movement
                    this.velocityX = this.moveDirection * this.speed;

                    // Update frame based on movement direction
                    if (this.moveDirection < 0) {
                        this.facingRight = false;
                        this.currentFrame = 0; // Top frame for left movement
                    } else {
                        this.facingRight = true;
                        this.currentFrame = 1; // Bottom frame for right movement
                    }

                    // Random jumping
                    this.jumpTimer--;
                    if (this.jumpTimer <= 0 && this.onGround) {
                        this.velocityY = this.jumpPower;
                        this.jumpTimer = Math.floor(Math.random() * 120) + 60;
                    }

                    // Change direction at edges
                    if (this.x < 0 || this.x > canvas.width - this.width) {
                        this.moveDirection *= -1;
                    }
                }

                // Apply velocity
                this.x += this.velocityX;
                this.y += this.velocityY;

                // Reset ground status
                this.onGround = false;

                // Platform collision detection (one-way platforms - can jump through from below)
                for (let platform of game.platforms) {
                    if (this.checkPlatformCollision(platform)) {
                        // Only collide when landing on top (coming down from above)
                        // Allow jumping through from below
                        if (this.velocityY > 0 && this.y + this.height - this.velocityY <= platform.y + 10) {
                            this.y = platform.y - this.height;
                            this.velocityY = 0;
                            this.onGround = true;
                        }
                    }
                }

                // Keep in bounds horizontally
                if (this.x < 0) {
                    this.x = 0;
                    if (!this.isPlayer) this.moveDirection = 1;
                }
                if (this.x > canvas.width - this.width) {
                    this.x = canvas.width - this.width;
                    if (!this.isPlayer) this.moveDirection = -1;
                }

                // Terminal velocity
                if (this.velocityY > 15) {
                    this.velocityY = 15;
                }
            }

            checkPlatformCollision(platform) {
                return this.x < platform.x + platform.width &&
                       this.x + this.width > platform.x &&
                       this.y < platform.y + platform.height &&
                       this.y + this.height > platform.y;
            }

            draw(cameraX, cameraY) {
                if (!this.loaded) return;

                // Save context state
                ctx.save();

                // Draw the current frame (split horizontally)
                ctx.drawImage(
                    this.image,
                    0, // source x
                    this.currentFrame * this.frameHeight, // source y (0 for frame 0, frameHeight for frame 1)
                    this.frameWidth, // source width
                    this.frameHeight, // source height
                    Math.floor(this.x - cameraX), // destination x (camera adjusted)
                    Math.floor(this.y - cameraY), // destination y (camera adjusted)
                    this.width, // destination width (scaled)
                    this.height // destination height (scaled)
                );

                // Draw name tag for player
                if (this.isPlayer) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(this.x - cameraX, this.y - cameraY - 20, this.width, 15);
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('PLAYER', this.x - cameraX + this.width / 2, this.y - cameraY - 8);
                }

                ctx.restore();
            }

            checkCollision(other) {
                return this.x < other.x + other.width &&
                       this.x + this.width > other.x &&
                       this.y < other.y + other.height &&
                       this.y + this.height > other.y;
            }
        }

        // Initialize game
        function init() {
            // Create platforms for the platformer level - Extended complex level
            // Ground sections (with strategic gaps)
            game.platforms.push(new Platform(0, 550, 500, 50, '#2d5016'));
            game.platforms.push(new Platform(700, 550, 600, 50, '#2d5016'));
            game.platforms.push(new Platform(1500, 550, 500, 50, '#2d5016'));
            game.platforms.push(new Platform(2200, 550, 600, 50, '#2d5016'));
            game.platforms.push(new Platform(3000, 550, 500, 50, '#2d5016'));
            game.platforms.push(new Platform(3700, 550, 600, 50, '#2d5016'));
            game.platforms.push(new Platform(4500, 550, 500, 50, '#2d5016'));
            game.platforms.push(new Platform(5200, 550, 600, 50, '#2d5016'));
            game.platforms.push(new Platform(6000, 550, 400, 50, '#2d5016'));

            // Section 1: Tutorial area (0-800)
            game.platforms.push(new Platform(100, 480, 120, 15, '#8B4513'));
            game.platforms.push(new Platform(280, 420, 100, 15, '#8B4513'));
            game.platforms.push(new Platform(450, 360, 120, 15, '#8B4513'));
            game.platforms.push(new Platform(620, 480, 80, 15, '#8B4513'));

            // Section 2: Stepping stones (800-1500)
            game.platforms.push(new Platform(850, 480, 90, 15, '#8B4513'));
            game.platforms.push(new Platform(1000, 420, 80, 15, '#8B4513'));
            game.platforms.push(new Platform(1150, 380, 90, 15, '#8B4513'));
            game.platforms.push(new Platform(1300, 420, 100, 15, '#8B4513'));

            // Section 3: Mid-level maze (1500-2200)
            game.platforms.push(new Platform(1550, 480, 120, 15, '#8B4513'));
            game.platforms.push(new Platform(1730, 420, 100, 15, '#8B4513'));
            game.platforms.push(new Platform(1600, 360, 110, 15, '#8B4513'));
            game.platforms.push(new Platform(1880, 360, 120, 15, '#8B4513'));
            game.platforms.push(new Platform(1750, 300, 100, 15, '#8B4513'));
            game.platforms.push(new Platform(2050, 400, 140, 15, '#8B4513'));

            // Section 4: Tower climb (2200-2800)
            game.platforms.push(new Platform(2250, 480, 100, 15, '#8B4513'));
            game.platforms.push(new Platform(2380, 420, 90, 15, '#8B4513'));
            game.platforms.push(new Platform(2280, 360, 90, 15, '#8B4513'));
            game.platforms.push(new Platform(2410, 300, 90, 15, '#8B4513'));
            game.platforms.push(new Platform(2320, 240, 100, 15, '#8B4513'));
            game.platforms.push(new Platform(2450, 180, 100, 15, '#8B4513'));
            game.platforms.push(new Platform(2350, 120, 100, 15, '#8B4513'));
            game.platforms.push(new Platform(2480, 60, 120, 15, '#8B4513'));
            game.platforms.push(new Platform(2650, 140, 100, 15, '#8B4513'));
            game.platforms.push(new Platform(2720, 240, 110, 15, '#8B4513'));

            // Section 5: Long jump challenge (2800-3500)
            game.platforms.push(new Platform(2900, 420, 90, 15, '#8B4513'));
            game.platforms.push(new Platform(3080, 380, 80, 15, '#8B4513'));
            game.platforms.push(new Platform(3250, 360, 90, 15, '#8B4513'));
            game.platforms.push(new Platform(3100, 280, 100, 15, '#8B4513'));
            game.platforms.push(new Platform(3400, 480, 90, 15, '#8B4513'));

            // Section 6: High peaks (3500-4200)
            game.platforms.push(new Platform(3600, 480, 120, 15, '#8B4513'));
            game.platforms.push(new Platform(3780, 420, 100, 15, '#8B4513'));
            game.platforms.push(new Platform(3950, 360, 110, 15, '#8B4513'));
            game.platforms.push(new Platform(3800, 280, 100, 15, '#8B4513'));
            game.platforms.push(new Platform(4000, 220, 100, 15, '#8B4513'));
            game.platforms.push(new Platform(3850, 160, 110, 15, '#8B4513'));
            game.platforms.push(new Platform(4050, 100, 100, 15, '#8B4513'));
            game.platforms.push(new Platform(4200, 200, 120, 15, '#8B4513'));

            // Section 7: Cave-like section (4200-4900)
            game.platforms.push(new Platform(4350, 320, 100, 15, '#8B4513'));
            game.platforms.push(new Platform(4520, 380, 120, 15, '#8B4513'));
            game.platforms.push(new Platform(4400, 460, 90, 15, '#8B4513'));
            game.platforms.push(new Platform(4700, 440, 100, 15, '#8B4513'));
            game.platforms.push(new Platform(4600, 360, 80, 15, '#8B4513'));
            game.platforms.push(new Platform(4820, 300, 100, 15, '#8B4513'));

            // Section 8: Multi-layer platforming (4900-5600)
            game.platforms.push(new Platform(5000, 480, 100, 15, '#8B4513'));
            game.platforms.push(new Platform(5150, 420, 90, 15, '#8B4513'));
            game.platforms.push(new Platform(5300, 360, 100, 15, '#8B4513'));
            game.platforms.push(new Platform(5180, 300, 90, 15, '#8B4513'));
            game.platforms.push(new Platform(5350, 240, 100, 15, '#8B4513'));
            game.platforms.push(new Platform(5500, 320, 110, 15, '#8B4513'));
            game.platforms.push(new Platform(5400, 180, 90, 15, '#8B4513'));

            // Section 9: Final descent (5600-6400)
            game.platforms.push(new Platform(5680, 480, 100, 15, '#8B4513'));
            game.platforms.push(new Platform(5820, 420, 110, 15, '#8B4513'));
            game.platforms.push(new Platform(5980, 360, 100, 15, '#8B4513'));
            game.platforms.push(new Platform(5850, 280, 110, 15, '#8B4513'));
            game.platforms.push(new Platform(6020, 220, 100, 15, '#8B4513'));
            game.platforms.push(new Platform(6150, 300, 120, 15, '#8B4513'));
            game.platforms.push(new Platform(6300, 400, 100, 15, '#8B4513'));

            // Create player at start
            game.player = new Character('player.png', 100, 480, true);
            game.characters.push(game.player);

            // Create NPCs with different sprites throughout the extended level
            const npcSprites = [
                'npc1.png', 'npc2.png', 'sprite.png', 'sprite2.png',
                'sprite3.png', 'sprite4.png', 'sprite5.png', 'dinggusen.png',
                'gressgusen.png', 'lanternegusen.png', 'lunagusen.png',
                'spaghettigusen.png', 'wirelessgusen.png', 'generatorgusen.png'
            ];

            // Place NPCs throughout the extended level
            const npcPositions = [
                { x: 120, y: 410 }, { x: 300, y: 350 }, { x: 640, y: 410 },     // Section 1
                { x: 870, y: 410 }, { x: 1170, y: 310 }, { x: 1320, y: 350 },   // Section 2
                { x: 1570, y: 410 }, { x: 1900, y: 290 }, { x: 2070, y: 330 },  // Section 3
                { x: 2270, y: 410 }, { x: 2370, y: 50 }, { x: 2740, y: 170 },   // Section 4
                { x: 2920, y: 350 }, { x: 3120, y: 210 }, { x: 3420, y: 410 },  // Section 5
                { x: 3620, y: 410 }, { x: 4070, y: 30 }, { x: 4220, y: 130 },   // Section 6
                { x: 4540, y: 310 }, { x: 4720, y: 370 }, { x: 4840, y: 230 },  // Section 7
                { x: 5020, y: 410 }, { x: 5320, y: 290 }, { x: 5520, y: 250 },  // Section 8
                { x: 5700, y: 410 }, { x: 6040, y: 150 }, { x: 6320, y: 330 },  // Section 9
            ];

            for (let i = 0; i < Math.min(npcPositions.length, npcSprites.length * 2); i++) {
                const sprite = npcSprites[i % npcSprites.length];
                const pos = npcPositions[i];
                game.characters.push(new Character(sprite, pos.x, pos.y, false));
            }

            console.log(`Platformer initialized with ${game.characters.length} characters and ${game.platforms.length} platforms`);
            console.log(`World size: ${game.worldWidth}x${game.worldHeight}`);
            console.log(`Loading ${game.totalAssets} assets...`);
        }

        // Draw forest background elements
        function drawForest(cameraX) {
            const parallaxBg = cameraX * 0.5; // Background elements move slower
            const parallaxFg = cameraX * 0.8; // Foreground elements move faster

            // Background trees (far away, slower parallax)
            ctx.fillStyle = '#1a4d1a';
            for (let i = 0; i < 30; i++) {
                const x = i * 400 - parallaxBg;
                const treeHeight = 180 + (i % 3) * 20;
                if (x > -100 && x < canvas.width + 100) {
                    // Tree trunk
                    ctx.fillStyle = '#3d2817';
                    ctx.fillRect(x, canvas.height - 150 - treeHeight, 25, treeHeight);

                    // Tree canopy
                    ctx.fillStyle = '#1a4d1a';
                    ctx.beginPath();
                    ctx.ellipse(x + 12, canvas.height - 150 - treeHeight, 50, 70, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(x + 12, canvas.height - 170 - treeHeight, 40, 50, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Foreground trees (closer, faster parallax)
            for (let i = 0; i < 50; i++) {
                const x = i * 250 - parallaxFg;
                const treeHeight = 200 + (i % 4) * 25;
                if (x > -100 && x < canvas.width + 100) {
                    // Tree trunk
                    ctx.fillStyle = '#4a3420';
                    ctx.fillRect(x, canvas.height - 100 - treeHeight, 30, treeHeight);

                    // Tree canopy
                    ctx.fillStyle = '#2d5a2d';
                    ctx.beginPath();
                    ctx.ellipse(x + 15, canvas.height - 100 - treeHeight, 60, 80, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(x + 15, canvas.height - 130 - treeHeight, 50, 60, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Bushes (world position, full camera movement)
            ctx.fillStyle = '#2d5a2d';
            for (let i = 0; i < 80; i++) {
                const x = i * 180 - cameraX;
                const y = canvas.height - 70 - (i % 3) * 10;
                if (x > -60 && x < canvas.width + 60) {
                    ctx.beginPath();
                    ctx.ellipse(x, y, 35, 25, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(x + 20, y - 5, 30, 22, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Grass tufts
            ctx.fillStyle = '#3d7a3d';
            for (let i = 0; i < 150; i++) {
                const x = i * 90 - cameraX;
                const y = canvas.height - 50;
                if (x > -30 && x < canvas.width + 30) {
                    ctx.fillRect(x, y, 3, 15);
                    ctx.fillRect(x + 4, y + 2, 3, 13);
                    ctx.fillRect(x + 8, y, 3, 14);
                }
            }

            // Flowers (small colored dots)
            const flowerColors = ['#ffeb3b', '#ff5722', '#e91e63', '#9c27b0', '#ffffff'];
            for (let i = 0; i < 100; i++) {
                const x = i * 120 + 30 - cameraX;
                const y = canvas.height - 60 - (i % 5) * 3;
                if (x > -10 && x < canvas.width + 10) {
                    ctx.fillStyle = flowerColors[i % flowerColors.length];
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, Math.PI * 2);
                    ctx.fill();
                    // Stem
                    ctx.fillStyle = '#3d7a3d';
                    ctx.fillRect(x - 1, y, 2, 12);
                }
            }
        }

        // Game loop
        function gameLoop() {
            // Clear canvas with sky color
            ctx.fillStyle = '#87ceeb';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Show loading screen if assets aren't loaded
            if (!game.gameStarted) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'white';
                ctx.font = 'bold 32px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Loading...', canvas.width / 2, canvas.height / 2 - 20);
                ctx.font = '20px Arial';
                ctx.fillText(`${game.assetsLoaded} / ${game.totalAssets} sprites loaded`, canvas.width / 2, canvas.height / 2 + 20);
                requestAnimationFrame(gameLoop);
                return;
            }

            // Update camera to follow player (centered, with world bounds)
            if (game.player) {
                // Center camera on player
                game.camera.x = game.player.x - canvas.width / 2 + game.player.width / 2;
                game.camera.y = game.player.y - canvas.height / 2 + game.player.height / 2;

                // Keep camera within world bounds
                game.camera.x = Math.max(0, Math.min(game.camera.x, game.worldWidth - canvas.width));
                game.camera.y = Math.max(0, Math.min(game.camera.y, game.worldHeight - canvas.height));
            }

            // Draw forest background with parallax
            drawForest(game.camera.x);

            // Draw parallax clouds (slower movement for depth effect)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            const cloudParallax = game.camera.x * 0.3; // Move slower than camera

            ctx.beginPath();
            ctx.arc(100 - cloudParallax, 80, 30, 0, Math.PI * 2);
            ctx.arc(130 - cloudParallax, 80, 40, 0, Math.PI * 2);
            ctx.arc(160 - cloudParallax, 80, 30, 0, Math.PI * 2);
            ctx.fill();

            ctx.beginPath();
            ctx.arc(500 - cloudParallax, 120, 35, 0, Math.PI * 2);
            ctx.arc(535 - cloudParallax, 120, 45, 0, Math.PI * 2);
            ctx.arc(575 - cloudParallax, 120, 35, 0, Math.PI * 2);
            ctx.fill();

            ctx.beginPath();
            ctx.arc(1000 - cloudParallax, 90, 32, 0, Math.PI * 2);
            ctx.arc(1035 - cloudParallax, 90, 42, 0, Math.PI * 2);
            ctx.arc(1070 - cloudParallax, 90, 32, 0, Math.PI * 2);
            ctx.fill();

            ctx.beginPath();
            ctx.arc(1600 - cloudParallax, 100, 38, 0, Math.PI * 2);
            ctx.arc(1640 - cloudParallax, 100, 48, 0, Math.PI * 2);
            ctx.arc(1685 - cloudParallax, 100, 38, 0, Math.PI * 2);
            ctx.fill();

            ctx.beginPath();
            ctx.arc(2200 - cloudParallax, 85, 33, 0, Math.PI * 2);
            ctx.arc(2235 - cloudParallax, 85, 43, 0, Math.PI * 2);
            ctx.arc(2270 - cloudParallax, 85, 33, 0, Math.PI * 2);
            ctx.fill();

            ctx.beginPath();
            ctx.arc(2800 - cloudParallax, 110, 36, 0, Math.PI * 2);
            ctx.arc(2838 - cloudParallax, 110, 46, 0, Math.PI * 2);
            ctx.arc(2880 - cloudParallax, 110, 36, 0, Math.PI * 2);
            ctx.fill();

            // Update all characters
            game.characters.forEach(char => {
                char.update();
            });

            // Check collisions between player and NPCs
            if (game.player) {
                game.characters.forEach(char => {
                    if (!char.isPlayer && char.loaded && game.player.checkCollision(char)) {
                        // Simple collision response - bounce back
                        if (game.frame % 60 === 0) {
                            game.score += 10;
                            document.getElementById('score').textContent = 'Score: ' + game.score;
                        }
                    }
                });
            }

            // Draw platforms with camera offset
            game.platforms.forEach(platform => {
                platform.draw(game.camera.x, game.camera.y);
            });

            // Draw all characters with camera offset
            game.characters.forEach(char => {
                char.draw(game.camera.x, game.camera.y);
            });

            // Draw UI (fixed on screen, not affected by camera)
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(10, 10, 280, 50);
            ctx.fillStyle = 'white';
            ctx.font = '16px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('Position: ' + Math.floor(game.player ? game.player.x : 0) + 'px', 20, 30);
            ctx.fillText('Score: ' + game.score, 20, 50);

            game.frame++;
            requestAnimationFrame(gameLoop);
        }

        // Event listeners
        window.addEventListener('keydown', (e) => {
            game.keys[e.key] = true;
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
                e.preventDefault();
            }
        });

        window.addEventListener('keyup', (e) => {
            game.keys[e.key] = false;
        });

        // Start game
        init();
        gameLoop();
    </script>
</body>
</html>
