<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gusen Platformer Game</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Arial', sans-serif;
        }

        #gameContainer {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }

        canvas {
            border: 3px solid #333;
            display: block;
            background: #87ceeb;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            image-rendering: -moz-crisp-edges;
        }

        #controls {
            margin-top: 20px;
            padding: 15px;
            background: #f0f0f0;
            border-radius: 5px;
            text-align: center;
        }

        h1 {
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            margin-bottom: 20px;
        }

        .info {
            color: #333;
            margin: 5px 0;
        }

        .key {
            display: inline-block;
            padding: 5px 10px;
            background: #667eea;
            color: white;
            border-radius: 3px;
            margin: 0 3px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>üéÆ Gusen Platformer Game üéÆ</h1>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="controls">
            <div class="info">
                <strong>Controls:</strong>
                <span class="key">‚Üê</span>
                <span class="key">‚Üí</span>
                to move,
                <span class="key">‚Üë</span>
                <span class="key">W</span>
                <span class="key">Space</span>
                to jump
            </div>
            <div class="info">
                <strong>Goal:</strong> Jump across platforms and avoid NPCs!
            </div>
            <div class="info" id="score">Score: 0</div>
        </div>
    </div>

    <script>
        // ===== CONFIGURATION =====
        const CONFIG = {
            // Canvas settings
            canvas: {
                width: 800,
                height: 600
            },

            // World settings
            world: {
                width: 6400,
                height: 600
            },

            // Physics settings
            physics: {
                gravity: 0.4,
                terminalVelocity: 15,
                playerSpeed: 3,
                npcSpeed: 1.5,
                playerJumpPower: -9,
                npcJumpPower: -8
            },

            // Player settings
            player: {
                startX: 100,
                startY: 480,
                lives: 3,
                invincibilityFrames: 180, // 3 seconds at 60fps
                respawnFrames: 120 // 2 seconds at 60fps
            },

            // Sprite settings
            sprite: {
                scale: 4,
                defaultWidth: 64,
                defaultHeight: 64
            },

            // Parallax settings
            parallax: {
                clouds: 0.3,
                backgroundTrees: 0.5,
                foregroundTrees: 0.8
            },

            // Colors
            colors: {
                sky: '#87ceeb',
                ground: '#2d5016',
                platform: '#8B4513',
                platformBorder: '#654321',
                backgroundTree: '#1a4d1a',
                foregroundTree: '#2d5a2d',
                treeTrunk: '#4a3420',
                bush: '#2d5a2d',
                grass: '#3d7a3d',
                flowers: ['#ffeb3b', '#ff5722', '#e91e63', '#9c27b0', '#ffffff']
            },

            // NPC sprites list
            npcSprites: [
                'npc1.png', 'npc2.png', 'sprite.png', 'sprite2.png',
                'sprite3.png', 'sprite4.png', 'sprite5.png', 'dinggusen.png',
                'gressgusen.png', 'lanternegusen.png', 'lunagusen.png',
                'spaghettigusen.png', 'wirelessgusen.png', 'generatorgusen.png'
            ]
        };

        // ===== INITIALIZATION =====
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Disable image smoothing for crisp pixel art
        ctx.imageSmoothingEnabled = false;
        ctx.mozImageSmoothingEnabled = false;
        ctx.webkitImageSmoothingEnabled = false;
        ctx.msImageSmoothingEnabled = false;

        // ===== GAME STATE =====
        const game = {
            score: 0,
            frame: 0,
            keys: {},
            characters: [],
            player: null,
            platforms: [],
            camera: { x: 0, y: 0 },
            lives: CONFIG.player.lives,
            isDead: false,
            respawnTimer: 0,
            invincibilityTimer: 0,
            assetsLoaded: 0,
            totalAssets: 0,
            gameStarted: false
        };

        // ===== PLATFORM CLASS =====
        class Platform {
            constructor(x, y, width, height, color = CONFIG.colors.platform) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.color = color;
            }

            draw(cameraX, cameraY) {
                // Viewport culling - only draw if visible
                const screenX = this.x - cameraX;
                const screenY = this.y - cameraY;
                if (screenX + this.width < 0 || screenX > CONFIG.canvas.width ||
                    screenY + this.height < 0 || screenY > CONFIG.canvas.height) {
                    return;
                }

                ctx.fillStyle = this.color;
                ctx.fillRect(screenX, screenY, this.width, this.height);
                ctx.strokeStyle = CONFIG.colors.platformBorder;
                ctx.lineWidth = 2;
                ctx.strokeRect(screenX, screenY, this.width, this.height);
            }

            checkCollision(character) {
                return character.x < this.x + this.width &&
                       character.x + character.width > this.x &&
                       character.y < this.y + this.height &&
                       character.y + character.height > this.y;
            }
        }

        // ===== CHARACTER CLASS =====
        class Character {
            constructor(imagePath, x, y, isPlayer = false) {
                this.x = x;
                this.y = y;
                this.scale = CONFIG.sprite.scale;
                this.width = CONFIG.sprite.defaultWidth;
                this.height = CONFIG.sprite.defaultHeight;
                this.velocityX = 0;
                this.velocityY = 0;
                this.speed = isPlayer ? CONFIG.physics.playerSpeed : CONFIG.physics.npcSpeed;
                this.jumpPower = isPlayer ? CONFIG.physics.playerJumpPower : CONFIG.physics.npcJumpPower;
                this.isPlayer = isPlayer;
                this.onGround = false;
                this.image = new Image();
                this.image.src = imagePath;
                this.loaded = false;
                this.currentFrame = 1; // Start facing right
                this.facingRight = true;
                this.name = imagePath.replace('.png', '');

                // NPC-specific properties
                if (!isPlayer) {
                    this.moveDirection = Math.random() > 0.5 ? 1 : -1;
                    this.jumpTimer = Math.floor(Math.random() * 60) + 30;
                    this.facingRight = this.moveDirection > 0;
                    this.currentFrame = this.facingRight ? 1 : 0;
                }

                game.totalAssets++;
                this.setupImageHandlers();
            }

            setupImageHandlers() {
                this.image.onload = () => {
                    this.loaded = true;
                    game.assetsLoaded++;
                    this.frameHeight = this.image.height / 2;
                    this.frameWidth = this.image.width;
                    this.width = this.frameWidth * this.scale;
                    this.height = this.frameHeight * this.scale;

                    if (game.assetsLoaded === game.totalAssets) {
                        game.gameStarted = true;
                        console.log('All assets loaded!');
                    }
                };

                this.image.onerror = () => {
                    console.error(`Failed to load: ${this.name}`);
                    game.assetsLoaded++;
                    if (game.assetsLoaded === game.totalAssets) {
                        game.gameStarted = true;
                    }
                };
            }

            update() {
                this.velocityY += CONFIG.physics.gravity;

                if (this.isPlayer) {
                    this.updatePlayer();
                } else {
                    this.updateNPC();
                }

                // Apply velocity
                this.x += this.velocityX;
                this.y += this.velocityY;

                // Platform collision (one-way platforms)
                this.onGround = false;
                for (let platform of game.platforms) {
                    if (this.checkPlatformCollision(platform)) {
                        if (this.velocityY > 0 && this.y + this.height - this.velocityY <= platform.y + 10) {
                            this.y = platform.y - this.height;
                            this.velocityY = 0;
                            this.onGround = true;
                        }
                    }
                }

                // World bounds
                this.x = Math.max(0, Math.min(this.x, CONFIG.world.width - this.width));

                // Terminal velocity
                if (this.velocityY > CONFIG.physics.terminalVelocity) {
                    this.velocityY = CONFIG.physics.terminalVelocity;
                }

                // NPC bounds and direction change
                if (!this.isPlayer && (this.x <= 0 || this.x >= CONFIG.world.width - this.width)) {
                    this.moveDirection *= -1;
                }
            }

            updatePlayer() {
                this.velocityX = 0;

                if (game.keys['ArrowLeft'] || game.keys['a']) {
                    this.velocityX = -this.speed;
                    this.facingRight = false;
                    this.currentFrame = 0;
                }
                if (game.keys['ArrowRight'] || game.keys['d']) {
                    this.velocityX = this.speed;
                    this.facingRight = true;
                    this.currentFrame = 1;
                }

                if ((game.keys['ArrowUp'] || game.keys['w'] || game.keys[' ']) && this.onGround) {
                    this.velocityY = this.jumpPower;
                    this.onGround = false;
                }
            }

            updateNPC() {
                this.velocityX = this.moveDirection * this.speed;
                this.currentFrame = this.moveDirection > 0 ? 1 : 0;
                this.facingRight = this.moveDirection > 0;

                this.jumpTimer--;
                if (this.jumpTimer <= 0 && this.onGround) {
                    this.velocityY = this.jumpPower;
                    this.jumpTimer = Math.floor(Math.random() * 120) + 60;
                }
            }

            checkPlatformCollision(platform) {
                return this.x < platform.x + platform.width &&
                       this.x + this.width > platform.x &&
                       this.y < platform.y + platform.height &&
                       this.y + this.height > platform.y;
            }

            draw(cameraX, cameraY) {
                if (!this.loaded) return;

                // Viewport culling
                const screenX = this.x - cameraX;
                const screenY = this.y - cameraY;
                if (screenX + this.width < -100 || screenX > CONFIG.canvas.width + 100 ||
                    screenY + this.height < -100 || screenY > CONFIG.canvas.height + 100) {
                    return;
                }

                ctx.save();

                // Invincibility flash
                if (this.isPlayer && game.invincibilityTimer > 0 && Math.floor(game.invincibilityTimer / 10) % 2 === 0) {
                    ctx.globalAlpha = 0.5;
                }

                ctx.drawImage(
                    this.image,
                    0,
                    this.currentFrame * this.frameHeight,
                    this.frameWidth,
                    this.frameHeight,
                    Math.floor(screenX),
                    Math.floor(screenY),
                    this.width,
                    this.height
                );

                // Player name tag
                if (this.isPlayer) {
                    ctx.globalAlpha = 1.0;
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(screenX, screenY - 20, this.width, 15);
                    ctx.fillStyle = game.invincibilityTimer > 0 ? '#ffff00' : 'white';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('PLAYER', screenX + this.width / 2, screenY - 8);
                }

                ctx.restore();
            }

            checkCollision(other) {
                return this.x < other.x + other.width &&
                       this.x + this.width > other.x &&
                       this.y < other.y + other.height &&
                       this.y + this.height > other.y;
            }
        }

        // ===== LEVEL DATA =====
        const LEVEL_DATA = {
            groundPlatforms: [
                { x: 0, y: 550, w: 500 }, { x: 700, y: 550, w: 600 },
                { x: 1500, y: 550, w: 500 }, { x: 2200, y: 550, w: 600 },
                { x: 3000, y: 550, w: 500 }, { x: 3700, y: 550, w: 600 },
                { x: 4500, y: 550, w: 500 }, { x: 5200, y: 550, w: 600 },
                { x: 6000, y: 550, w: 400 }
            ],
            sections: [
                // Section 1: Tutorial (0-800)
                [
                    { x: 100, y: 480, w: 120 }, { x: 280, y: 420, w: 100 },
                    { x: 450, y: 360, w: 120 }, { x: 620, y: 480, w: 80 }
                ],
                // Section 2: Stepping stones (800-1500)
                [
                    { x: 850, y: 480, w: 90 }, { x: 1000, y: 420, w: 80 },
                    { x: 1150, y: 380, w: 90 }, { x: 1300, y: 420, w: 100 }
                ],
                // Section 3: Mid-level maze (1500-2200)
                [
                    { x: 1550, y: 480, w: 120 }, { x: 1730, y: 420, w: 100 },
                    { x: 1600, y: 360, w: 110 }, { x: 1880, y: 360, w: 120 },
                    { x: 1750, y: 300, w: 100 }, { x: 2050, y: 400, w: 140 }
                ],
                // Section 4: Tower climb (2200-2800)
                [
                    { x: 2250, y: 480, w: 100 }, { x: 2380, y: 420, w: 90 },
                    { x: 2280, y: 360, w: 90 }, { x: 2410, y: 300, w: 90 },
                    { x: 2320, y: 240, w: 100 }, { x: 2450, y: 180, w: 100 },
                    { x: 2350, y: 120, w: 100 }, { x: 2480, y: 60, w: 120 },
                    { x: 2650, y: 140, w: 100 }, { x: 2720, y: 240, w: 110 }
                ],
                // Section 5: Long jumps (2800-3500)
                [
                    { x: 2900, y: 420, w: 90 }, { x: 3080, y: 380, w: 80 },
                    { x: 3250, y: 360, w: 90 }, { x: 3100, y: 280, w: 100 },
                    { x: 3400, y: 480, w: 90 }
                ],
                // Section 6: High peaks (3500-4200)
                [
                    { x: 3600, y: 480, w: 120 }, { x: 3780, y: 420, w: 100 },
                    { x: 3950, y: 360, w: 110 }, { x: 3800, y: 280, w: 100 },
                    { x: 4000, y: 220, w: 100 }, { x: 3850, y: 160, w: 110 },
                    { x: 4050, y: 100, w: 100 }, { x: 4200, y: 200, w: 120 }
                ],
                // Section 7: Cave section (4200-4900)
                [
                    { x: 4350, y: 320, w: 100 }, { x: 4520, y: 380, w: 120 },
                    { x: 4400, y: 460, w: 90 }, { x: 4700, y: 440, w: 100 },
                    { x: 4600, y: 360, w: 80 }, { x: 4820, y: 300, w: 100 }
                ],
                // Section 8: Multi-layer (4900-5600)
                [
                    { x: 5000, y: 480, w: 100 }, { x: 5150, y: 420, w: 90 },
                    { x: 5300, y: 360, w: 100 }, { x: 5180, y: 300, w: 90 },
                    { x: 5350, y: 240, w: 100 }, { x: 5500, y: 320, w: 110 },
                    { x: 5400, y: 180, w: 90 }
                ],
                // Section 9: Final descent (5600-6400)
                [
                    { x: 5680, y: 480, w: 100 }, { x: 5820, y: 420, w: 110 },
                    { x: 5980, y: 360, w: 100 }, { x: 5850, y: 280, w: 110 },
                    { x: 6020, y: 220, w: 100 }, { x: 6150, y: 300, w: 120 },
                    { x: 6300, y: 400, w: 100 }
                ]
            ],
            npcPositions: [
                { x: 120, y: 410 }, { x: 300, y: 350 }, { x: 640, y: 410 },
                { x: 870, y: 410 }, { x: 1170, y: 310 }, { x: 1320, y: 350 },
                { x: 1570, y: 410 }, { x: 1900, y: 290 }, { x: 2070, y: 330 },
                { x: 2270, y: 410 }, { x: 2370, y: 50 }, { x: 2740, y: 170 },
                { x: 2920, y: 350 }, { x: 3120, y: 210 }, { x: 3420, y: 410 },
                { x: 3620, y: 410 }, { x: 4070, y: 30 }, { x: 4220, y: 130 },
                { x: 4540, y: 310 }, { x: 4720, y: 370 }, { x: 4840, y: 230 },
                { x: 5020, y: 410 }, { x: 5320, y: 290 }, { x: 5520, y: 250 },
                { x: 5700, y: 410 }, { x: 6040, y: 150 }, { x: 6320, y: 330 }
            ]
        };

        // ===== GAME INITIALIZATION =====
        function init() {
            // Create ground platforms
            LEVEL_DATA.groundPlatforms.forEach(p => {
                game.platforms.push(new Platform(p.x, p.y, p.w, 50, CONFIG.colors.ground));
            });

            // Create section platforms
            LEVEL_DATA.sections.forEach(section => {
                section.forEach(p => {
                    game.platforms.push(new Platform(p.x, p.y, p.w, 15));
                });
            });

            // Create player
            game.player = new Character('player.png', CONFIG.player.startX, CONFIG.player.startY, true);
            game.characters.push(game.player);

            // Create NPCs
            LEVEL_DATA.npcPositions.forEach((pos, i) => {
                const sprite = CONFIG.npcSprites[i % CONFIG.npcSprites.length];
                game.characters.push(new Character(sprite, pos.x, pos.y, false));
            });

            console.log(`Game initialized: ${game.characters.length} characters, ${game.platforms.length} platforms`);
        }

        // ===== DEATH SYSTEM =====
        function killPlayer() {
            if (game.invincibilityTimer > 0 || game.isDead) return;
            game.lives--;
            game.isDead = true;
            game.respawnTimer = CONFIG.player.respawnFrames;
        }

        function respawnPlayer() {
            if (!game.isDead || game.respawnTimer > 0 || game.lives <= 0) return;
            game.player.x = CONFIG.player.startX;
            game.player.y = CONFIG.player.startY;
            game.player.velocityX = 0;
            game.player.velocityY = 0;
            game.isDead = false;
            game.invincibilityTimer = CONFIG.player.invincibilityFrames;
        }

        // ===== RENDERING =====
        function drawForest(cameraX) {
            const parallaxBg = cameraX * CONFIG.parallax.backgroundTrees;
            const parallaxFg = cameraX * CONFIG.parallax.foregroundTrees;

            // Background trees
            for (let i = 0; i < 30; i++) {
                const x = i * 400 - parallaxBg;
                if (x < -100 || x > CONFIG.canvas.width + 100) continue;

                const treeHeight = 180 + (i % 3) * 20;
                ctx.fillStyle = '#3d2817';
                ctx.fillRect(x, CONFIG.canvas.height - treeHeight, 25, treeHeight);
                ctx.fillStyle = CONFIG.colors.backgroundTree;
                ctx.beginPath();
                ctx.ellipse(x + 12, CONFIG.canvas.height - treeHeight, 50, 70, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(x + 12, CONFIG.canvas.height - treeHeight - 20, 40, 50, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            // Foreground trees
            for (let i = 0; i < 50; i++) {
                const x = i * 250 - parallaxFg;
                if (x < -100 || x > CONFIG.canvas.width + 100) continue;

                const treeHeight = 200 + (i % 4) * 25;
                ctx.fillStyle = CONFIG.colors.treeTrunk;
                ctx.fillRect(x, CONFIG.canvas.height - treeHeight, 30, treeHeight);
                ctx.fillStyle = CONFIG.colors.foregroundTree;
                ctx.beginPath();
                ctx.ellipse(x + 15, CONFIG.canvas.height - treeHeight, 60, 80, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(x + 15, CONFIG.canvas.height - treeHeight - 30, 50, 60, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            // Bushes and foliage (simplified for performance)
            ctx.fillStyle = CONFIG.colors.bush;
            for (let i = 0; i < 80; i++) {
                const x = i * 180 - cameraX;
                if (x < -60 || x > CONFIG.canvas.width + 60) continue;
                const y = CONFIG.canvas.height - 70 - (i % 3) * 10;
                ctx.beginPath();
                ctx.ellipse(x, y, 35, 25, 0, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawClouds(cloudParallax) {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            const clouds = [
                { x: 100, y: 80 }, { x: 500, y: 120 }, { x: 1000, y: 90 },
                { x: 1600, y: 100 }, { x: 2200, y: 85 }, { x: 2800, y: 110 }
            ];

            clouds.forEach(cloud => {
                const x = cloud.x - cloudParallax;
                if (x < -200 || x > CONFIG.canvas.width + 200) return;
                ctx.beginPath();
                ctx.arc(x, cloud.y, 30, 0, Math.PI * 2);
                ctx.arc(x + 30, cloud.y, 40, 0, Math.PI * 2);
                ctx.arc(x + 60, cloud.y, 30, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawUI() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(10, 10, 280, 70);
            ctx.fillStyle = 'white';
            ctx.font = '16px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('Position: ' + Math.floor(game.player.x) + 'px', 20, 30);
            ctx.fillText('Score: ' + game.score, 20, 50);
            ctx.fillStyle = game.lives > 0 ? '#ff0000' : '#666666';
            ctx.fillText('Lives: ' + '‚ô•'.repeat(game.lives), 20, 70);

            // Death/Game Over screen
            if (game.isDead) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(0, 0, CONFIG.canvas.width, CONFIG.canvas.height);
                ctx.font = 'bold 48px Arial';
                ctx.textAlign = 'center';
                ctx.fillStyle = '#ff0000';

                if (game.lives > 0) {
                    ctx.fillText('YOU DIED!', CONFIG.canvas.width / 2, CONFIG.canvas.height / 2 - 40);
                    ctx.font = '24px Arial';
                    ctx.fillStyle = 'white';
                    ctx.fillText('Respawning in ' + Math.ceil(game.respawnTimer / 60) + '...', CONFIG.canvas.width / 2, CONFIG.canvas.height / 2 + 20);
                } else {
                    ctx.fillText('GAME OVER!', CONFIG.canvas.width / 2, CONFIG.canvas.height / 2 - 40);
                    ctx.font = '24px Arial';
                    ctx.fillStyle = 'white';
                    ctx.fillText('Final Score: ' + game.score, CONFIG.canvas.width / 2, CONFIG.canvas.height / 2 + 20);
                    ctx.fillText('Refresh to play again', CONFIG.canvas.width / 2, CONFIG.canvas.height / 2 + 60);
                }
            }

            // Invincibility bar
            if (game.invincibilityTimer > 0 && !game.isDead) {
                ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
                ctx.fillRect(0, CONFIG.canvas.height - 10, (game.invincibilityTimer / CONFIG.player.invincibilityFrames) * CONFIG.canvas.width, 10);
            }
        }

        // ===== GAME LOOP =====
        function gameLoop() {
            ctx.fillStyle = CONFIG.colors.sky;
            ctx.fillRect(0, 0, CONFIG.canvas.width, CONFIG.canvas.height);

            // Loading screen
            if (!game.gameStarted) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(0, 0, CONFIG.canvas.width, CONFIG.canvas.height);
                ctx.fillStyle = 'white';
                ctx.font = 'bold 32px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Loading...', CONFIG.canvas.width / 2, CONFIG.canvas.height / 2 - 20);
                ctx.font = '20px Arial';
                ctx.fillText(`${game.assetsLoaded} / ${game.totalAssets}`, CONFIG.canvas.width / 2, CONFIG.canvas.height / 2 + 20);
                requestAnimationFrame(gameLoop);
                return;
            }

            // Update camera
            if (game.player) {
                game.camera.x = Math.max(0, Math.min(
                    game.player.x - CONFIG.canvas.width / 2 + game.player.width / 2,
                    CONFIG.world.width - CONFIG.canvas.width
                ));
            }

            // Draw background
            drawForest(game.camera.x);
            drawClouds(game.camera.x * CONFIG.parallax.clouds);

            // Update timers
            if (game.invincibilityTimer > 0) game.invincibilityTimer--;
            if (game.respawnTimer > 0) {
                game.respawnTimer--;
            } else {
                respawnPlayer();
            }

            // Update game logic
            if (!game.isDead) {
                game.characters.forEach(char => char.update());

                // Death checks
                if (game.player) {
                    if (game.player.y > CONFIG.world.height + 100) {
                        killPlayer();
                    }

                    if (game.invincibilityTimer === 0) {
                        game.characters.forEach(char => {
                            if (!char.isPlayer && char.loaded && game.player.checkCollision(char)) {
                                killPlayer();
                            }
                        });
                    }
                }
            }

            // Render
            game.platforms.forEach(p => p.draw(game.camera.x, game.camera.y));
            game.characters.forEach(c => c.draw(game.camera.x, game.camera.y));
            drawUI();

            game.frame++;
            requestAnimationFrame(gameLoop);
        }

        // ===== INPUT HANDLING =====
        window.addEventListener('keydown', (e) => {
            game.keys[e.key] = true;
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
                e.preventDefault();
            }
        });

        window.addEventListener('keyup', (e) => {
            game.keys[e.key] = false;
        });

        // ===== START GAME =====
        init();
        gameLoop();
    </script>
</body>
</html>
