<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gusen Platformer Game</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Arial', sans-serif;
        }

        #gameContainer {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }

        canvas {
            border: 3px solid #333;
            display: block;
            background: #87ceeb;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            image-rendering: -moz-crisp-edges;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        #controls {
            margin-top: 20px;
            padding: 15px;
            background: #f0f0f0;
            border-radius: 5px;
            text-align: center;
        }

        h1 {
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            margin-bottom: 20px;
        }

        .info {
            color: #333;
            margin: 5px 0;
        }

        .key {
            display: inline-block;
            padding: 5px 10px;
            background: #667eea;
            color: white;
            border-radius: 3px;
            margin: 0 3px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>üéÆ Gusen Platformer Game üéÆ</h1>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="controls">
            <div class="info">
                <strong>Controls:</strong>
                <span class="key">‚Üê</span>
                <span class="key">‚Üí</span>
                to move,
                <span class="key">‚Üë</span>
                <span class="key">W</span>
                <span class="key">Space</span>
                to jump
            </div>
            <div class="info">
                <strong>Goal:</strong> Jump across platforms and meet other characters!
            </div>
            <div class="info" id="score">Score: 0</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Disable image smoothing for crisp pixel art
        ctx.imageSmoothingEnabled = false;
        ctx.mozImageSmoothingEnabled = false;
        ctx.webkitImageSmoothingEnabled = false;
        ctx.msImageSmoothingEnabled = false;

        // Game state
        const game = {
            score: 0,
            frame: 0,
            keys: {},
            characters: [],
            player: null,
            assetsLoaded: 0,
            totalAssets: 0,
            gameStarted: false,
            gravity: 0.4,
            platforms: [],
            camera: {
                x: 0,
                y: 0
            },
            worldWidth: 3200,  // Much wider world for sidescrolling
            worldHeight: 600
        };

        // Platform class
        class Platform {
            constructor(x, y, width, height, color = '#8B4513') {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.color = color;
            }

            draw(cameraX, cameraY) {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - cameraX, this.y - cameraY, this.width, this.height);
                // Add some detail
                ctx.strokeStyle = '#654321';
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x - cameraX, this.y - cameraY, this.width, this.height);
            }

            checkCollision(character) {
                return character.x < this.x + this.width &&
                       character.x + character.width > this.x &&
                       character.y < this.y + this.height &&
                       character.y + character.height > this.y;
            }
        }

        // Sprite class to handle 2-frame directional animations
        // Frame 0 (top half) = Left movement
        // Frame 1 (bottom half) = Right movement
        class Character {
            constructor(imagePath, x, y, isPlayer = false) {
                this.x = x;
                this.y = y;
                this.scale = 4; // Scale up the tiny sprites
                this.width = 64; // Will be adjusted when image loads
                this.height = 64; // Will be adjusted when image loads
                this.velocityX = 0;
                this.velocityY = 0;
                this.speed = isPlayer ? 3 : 1.5;
                this.jumpPower = isPlayer ? -9 : -8;
                this.isPlayer = isPlayer;
                this.onGround = false;
                this.image = new Image();
                this.image.src = imagePath;
                this.loaded = false;
                this.currentFrame = 1; // Start facing right
                this.facingRight = true; // Track which direction we're facing
                this.name = imagePath.replace('.png', '');

                // Movement for NPCs
                if (!isPlayer) {
                    this.moveDirection = Math.random() > 0.5 ? 1 : -1;
                    this.jumpTimer = Math.floor(Math.random() * 60) + 30;
                    // Set initial frame based on initial direction
                    this.facingRight = this.moveDirection > 0;
                    this.currentFrame = this.facingRight ? 1 : 0;
                }

                game.totalAssets++;

                this.image.onload = () => {
                    this.loaded = true;
                    game.assetsLoaded++;
                    // Image is split horizontally: top half is frame 0, bottom half is frame 1
                    this.frameHeight = this.image.height / 2;
                    this.frameWidth = this.image.width;
                    // Adjust character size based on actual sprite size
                    this.width = this.frameWidth * this.scale;
                    this.height = this.frameHeight * this.scale;
                    console.log(`Loaded ${imagePath}: ${this.frameWidth}x${this.frameHeight} (scaled to ${this.width}x${this.height})`);

                    if (game.assetsLoaded === game.totalAssets) {
                        console.log('All assets loaded!');
                        game.gameStarted = true;
                    }
                };

                this.image.onerror = () => {
                    console.error(`Failed to load image: ${imagePath}`);
                    game.assetsLoaded++;
                    if (game.assetsLoaded === game.totalAssets) {
                        game.gameStarted = true;
                    }
                };
            }

            update() {
                // Apply gravity
                this.velocityY += game.gravity;

                if (this.isPlayer) {
                    // Player horizontal movement
                    this.velocityX = 0;

                    if (game.keys['ArrowLeft'] || game.keys['a']) {
                        this.velocityX = -this.speed;
                        this.facingRight = false;
                        this.currentFrame = 0; // Top frame for left movement
                    }
                    if (game.keys['ArrowRight'] || game.keys['d']) {
                        this.velocityX = this.speed;
                        this.facingRight = true;
                        this.currentFrame = 1; // Bottom frame for right movement
                    }

                    // Jump
                    if ((game.keys['ArrowUp'] || game.keys['w'] || game.keys[' ']) && this.onGround) {
                        this.velocityY = this.jumpPower;
                        this.onGround = false;
                    }
                } else {
                    // NPC movement
                    this.velocityX = this.moveDirection * this.speed;

                    // Update frame based on movement direction
                    if (this.moveDirection < 0) {
                        this.facingRight = false;
                        this.currentFrame = 0; // Top frame for left movement
                    } else {
                        this.facingRight = true;
                        this.currentFrame = 1; // Bottom frame for right movement
                    }

                    // Random jumping
                    this.jumpTimer--;
                    if (this.jumpTimer <= 0 && this.onGround) {
                        this.velocityY = this.jumpPower;
                        this.jumpTimer = Math.floor(Math.random() * 120) + 60;
                    }

                    // Change direction at edges
                    if (this.x < 0 || this.x > canvas.width - this.width) {
                        this.moveDirection *= -1;
                    }
                }

                // Apply velocity
                this.x += this.velocityX;
                this.y += this.velocityY;

                // Reset ground status
                this.onGround = false;

                // Platform collision detection
                for (let platform of game.platforms) {
                    if (this.checkPlatformCollision(platform)) {
                        // Landing on top of platform
                        if (this.velocityY > 0 && this.y + this.height - this.velocityY <= platform.y + 5) {
                            this.y = platform.y - this.height;
                            this.velocityY = 0;
                            this.onGround = true;
                        }
                        // Hitting bottom of platform
                        else if (this.velocityY < 0 && this.y - this.velocityY >= platform.y + platform.height) {
                            this.y = platform.y + platform.height;
                            this.velocityY = 0;
                        }
                        // Side collision
                        else {
                            if (this.velocityX > 0) {
                                this.x = platform.x - this.width;
                            } else if (this.velocityX < 0) {
                                this.x = platform.x + platform.width;
                            }
                            this.velocityX = 0;
                            if (!this.isPlayer) {
                                this.moveDirection *= -1;
                            }
                        }
                    }
                }

                // Keep in bounds horizontally
                if (this.x < 0) {
                    this.x = 0;
                    if (!this.isPlayer) this.moveDirection = 1;
                }
                if (this.x > canvas.width - this.width) {
                    this.x = canvas.width - this.width;
                    if (!this.isPlayer) this.moveDirection = -1;
                }

                // Terminal velocity
                if (this.velocityY > 15) {
                    this.velocityY = 15;
                }
            }

            checkPlatformCollision(platform) {
                return this.x < platform.x + platform.width &&
                       this.x + this.width > platform.x &&
                       this.y < platform.y + platform.height &&
                       this.y + this.height > platform.y;
            }

            draw(cameraX, cameraY) {
                if (!this.loaded) return;

                // Save context state
                ctx.save();

                // Draw the current frame (split horizontally)
                ctx.drawImage(
                    this.image,
                    0, // source x
                    this.currentFrame * this.frameHeight, // source y (0 for frame 0, frameHeight for frame 1)
                    this.frameWidth, // source width
                    this.frameHeight, // source height
                    Math.floor(this.x - cameraX), // destination x (camera adjusted)
                    Math.floor(this.y - cameraY), // destination y (camera adjusted)
                    this.width, // destination width (scaled)
                    this.height // destination height (scaled)
                );

                // Draw name tag for player
                if (this.isPlayer) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(this.x - cameraX, this.y - cameraY - 20, this.width, 15);
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('PLAYER', this.x - cameraX + this.width / 2, this.y - cameraY - 8);
                }

                ctx.restore();
            }

            checkCollision(other) {
                return this.x < other.x + other.width &&
                       this.x + this.width > other.x &&
                       this.y < other.y + other.height &&
                       this.y + this.height > other.y;
            }
        }

        // Initialize game
        function init() {
            // Create platforms for the platformer level - Complex sidescrolling level
            // Ground sections (with gaps for challenge)
            game.platforms.push(new Platform(0, 550, 400, 50, '#2d5016'));
            game.platforms.push(new Platform(600, 550, 400, 50, '#2d5016'));
            game.platforms.push(new Platform(1200, 550, 500, 50, '#2d5016'));
            game.platforms.push(new Platform(1900, 550, 400, 50, '#2d5016'));
            game.platforms.push(new Platform(2500, 550, 700, 50, '#2d5016'));

            // Starting area - tutorial section
            game.platforms.push(new Platform(100, 480, 120, 15, '#8B4513'));
            game.platforms.push(new Platform(280, 420, 100, 15, '#8B4513'));
            game.platforms.push(new Platform(450, 360, 120, 15, '#8B4513'));

            // First challenge - stepping stones over pit
            game.platforms.push(new Platform(420, 480, 80, 15, '#8B4513'));
            game.platforms.push(new Platform(520, 450, 60, 15, '#8B4513'));

            // Mid-level platforms
            game.platforms.push(new Platform(700, 480, 150, 15, '#8B4513'));
            game.platforms.push(new Platform(900, 420, 100, 15, '#8B4513'));
            game.platforms.push(new Platform(1050, 360, 120, 15, '#8B4513'));
            game.platforms.push(new Platform(800, 300, 100, 15, '#8B4513'));
            game.platforms.push(new Platform(650, 240, 120, 15, '#8B4513'));

            // Tall tower section
            game.platforms.push(new Platform(1220, 480, 100, 15, '#8B4513'));
            game.platforms.push(new Platform(1350, 420, 90, 15, '#8B4513'));
            game.platforms.push(new Platform(1270, 360, 90, 15, '#8B4513'));
            game.platforms.push(new Platform(1380, 300, 90, 15, '#8B4513'));
            game.platforms.push(new Platform(1300, 240, 100, 15, '#8B4513'));
            game.platforms.push(new Platform(1420, 180, 120, 15, '#8B4513'));
            game.platforms.push(new Platform(1320, 120, 100, 15, '#8B4513'));

            // Long jump section
            game.platforms.push(new Platform(1580, 380, 80, 15, '#8B4513'));
            game.platforms.push(new Platform(1750, 350, 80, 15, '#8B4513'));

            // High platforms
            game.platforms.push(new Platform(1920, 450, 140, 15, '#8B4513'));
            game.platforms.push(new Platform(2100, 380, 100, 15, '#8B4513'));
            game.platforms.push(new Platform(2250, 320, 120, 15, '#8B4513'));
            game.platforms.push(new Platform(2100, 250, 100, 15, '#8B4513'));
            game.platforms.push(new Platform(1950, 200, 120, 15, '#8B4513'));
            game.platforms.push(new Platform(2100, 140, 100, 15, '#8B4513'));

            // Final section - descending platforms
            game.platforms.push(new Platform(2420, 480, 100, 15, '#8B4513'));
            game.platforms.push(new Platform(2580, 420, 120, 15, '#8B4513'));
            game.platforms.push(new Platform(2750, 360, 100, 15, '#8B4513'));
            game.platforms.push(new Platform(2900, 300, 140, 15, '#8B4513'));
            game.platforms.push(new Platform(2700, 220, 120, 15, '#8B4513'));
            game.platforms.push(new Platform(2880, 160, 100, 15, '#8B4513'));
            game.platforms.push(new Platform(3050, 480, 150, 15, '#8B4513'));

            // Create player at start
            game.player = new Character('player.png', 100, 480, true);
            game.characters.push(game.player);

            // Create NPCs with different sprites throughout the level
            const npcSprites = [
                'npc1.png',
                'npc2.png',
                'sprite.png',
                'sprite2.png',
                'sprite3.png',
                'sprite4.png',
                'sprite5.png',
                'dinggusen.png',
                'gressgusen.png',
                'lanternegusen.png',
                'lunagusen.png',
                'spaghettigusen.png',
                'wirelessgusen.png',
                'generatorgusen.png'
            ];

            // Place NPCs throughout the level on various platforms
            const npcPositions = [
                { x: 120, y: 410 },   // Starting area
                { x: 300, y: 350 },   // Early platforms
                { x: 720, y: 410 },   // Mid section
                { x: 920, y: 350 },   // Mid platforms
                { x: 1240, y: 410 },  // Tower section
                { x: 1330, y: 290 },  // Tower middle
                { x: 1340, y: 50 },   // Tower top
                { x: 1600, y: 310 },  // Jump section
                { x: 2120, y: 310 },  // High section
                { x: 2270, y: 250 },  // Peak area
                { x: 2600, y: 350 },  // Final section
                { x: 3070, y: 410 },  // End area
            ];

            for (let i = 0; i < Math.min(npcPositions.length, npcSprites.length); i++) {
                const sprite = npcSprites[i];
                const pos = npcPositions[i];
                game.characters.push(new Character(sprite, pos.x, pos.y, false));
            }

            console.log(`Platformer initialized with ${game.characters.length} characters and ${game.platforms.length} platforms`);
            console.log(`World size: ${game.worldWidth}x${game.worldHeight}`);
            console.log(`Loading ${game.totalAssets} assets...`);
        }

        // Game loop
        function gameLoop() {
            // Clear canvas
            ctx.fillStyle = '#87ceeb';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Show loading screen if assets aren't loaded
            if (!game.gameStarted) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'white';
                ctx.font = 'bold 32px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Loading...', canvas.width / 2, canvas.height / 2 - 20);
                ctx.font = '20px Arial';
                ctx.fillText(`${game.assetsLoaded} / ${game.totalAssets} sprites loaded`, canvas.width / 2, canvas.height / 2 + 20);
                requestAnimationFrame(gameLoop);
                return;
            }

            // Update camera to follow player (centered, with world bounds)
            if (game.player) {
                // Center camera on player
                game.camera.x = game.player.x - canvas.width / 2 + game.player.width / 2;
                game.camera.y = game.player.y - canvas.height / 2 + game.player.height / 2;

                // Keep camera within world bounds
                game.camera.x = Math.max(0, Math.min(game.camera.x, game.worldWidth - canvas.width));
                game.camera.y = Math.max(0, Math.min(game.camera.y, game.worldHeight - canvas.height));
            }

            // Draw parallax clouds (slower movement for depth effect)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            const cloudParallax = game.camera.x * 0.3; // Move slower than camera

            ctx.beginPath();
            ctx.arc(100 - cloudParallax, 80, 30, 0, Math.PI * 2);
            ctx.arc(130 - cloudParallax, 80, 40, 0, Math.PI * 2);
            ctx.arc(160 - cloudParallax, 80, 30, 0, Math.PI * 2);
            ctx.fill();

            ctx.beginPath();
            ctx.arc(500 - cloudParallax, 120, 35, 0, Math.PI * 2);
            ctx.arc(535 - cloudParallax, 120, 45, 0, Math.PI * 2);
            ctx.arc(575 - cloudParallax, 120, 35, 0, Math.PI * 2);
            ctx.fill();

            ctx.beginPath();
            ctx.arc(1000 - cloudParallax, 90, 32, 0, Math.PI * 2);
            ctx.arc(1035 - cloudParallax, 90, 42, 0, Math.PI * 2);
            ctx.arc(1070 - cloudParallax, 90, 32, 0, Math.PI * 2);
            ctx.fill();

            ctx.beginPath();
            ctx.arc(1600 - cloudParallax, 100, 38, 0, Math.PI * 2);
            ctx.arc(1640 - cloudParallax, 100, 48, 0, Math.PI * 2);
            ctx.arc(1685 - cloudParallax, 100, 38, 0, Math.PI * 2);
            ctx.fill();

            ctx.beginPath();
            ctx.arc(2200 - cloudParallax, 85, 33, 0, Math.PI * 2);
            ctx.arc(2235 - cloudParallax, 85, 43, 0, Math.PI * 2);
            ctx.arc(2270 - cloudParallax, 85, 33, 0, Math.PI * 2);
            ctx.fill();

            ctx.beginPath();
            ctx.arc(2800 - cloudParallax, 110, 36, 0, Math.PI * 2);
            ctx.arc(2838 - cloudParallax, 110, 46, 0, Math.PI * 2);
            ctx.arc(2880 - cloudParallax, 110, 36, 0, Math.PI * 2);
            ctx.fill();

            // Update all characters
            game.characters.forEach(char => {
                char.update();
            });

            // Check collisions between player and NPCs
            if (game.player) {
                game.characters.forEach(char => {
                    if (!char.isPlayer && char.loaded && game.player.checkCollision(char)) {
                        // Simple collision response - bounce back
                        if (game.frame % 60 === 0) {
                            game.score += 10;
                            document.getElementById('score').textContent = 'Score: ' + game.score;
                        }
                    }
                });
            }

            // Draw platforms with camera offset
            game.platforms.forEach(platform => {
                platform.draw(game.camera.x, game.camera.y);
            });

            // Draw all characters with camera offset
            game.characters.forEach(char => {
                char.draw(game.camera.x, game.camera.y);
            });

            // Draw UI (fixed on screen, not affected by camera)
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(10, 10, 280, 50);
            ctx.fillStyle = 'white';
            ctx.font = '16px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('Position: ' + Math.floor(game.player ? game.player.x : 0) + 'px', 20, 30);
            ctx.fillText('Score: ' + game.score, 20, 50);

            game.frame++;
            requestAnimationFrame(gameLoop);
        }

        // Event listeners
        window.addEventListener('keydown', (e) => {
            game.keys[e.key] = true;
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
                e.preventDefault();
            }
        });

        window.addEventListener('keyup', (e) => {
            game.keys[e.key] = false;
        });

        // Start game
        init();
        gameLoop();
    </script>
</body>
</html>
