<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gusen Platformer Game</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Arial', sans-serif;
        }

        #gameContainer {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }

        canvas {
            border: 3px solid #333;
            display: block;
            background: #87ceeb;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            image-rendering: -moz-crisp-edges;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        #controls {
            margin-top: 20px;
            padding: 15px;
            background: #f0f0f0;
            border-radius: 5px;
            text-align: center;
        }

        h1 {
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            margin-bottom: 20px;
        }

        .info {
            color: #333;
            margin: 5px 0;
        }

        .key {
            display: inline-block;
            padding: 5px 10px;
            background: #667eea;
            color: white;
            border-radius: 3px;
            margin: 0 3px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>üéÆ Gusen Platformer Game üéÆ</h1>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="controls">
            <div class="info">
                <strong>Controls:</strong>
                <span class="key">‚Üê</span>
                <span class="key">‚Üí</span>
                to move,
                <span class="key">‚Üë</span>
                <span class="key">W</span>
                <span class="key">Space</span>
                to jump
            </div>
            <div class="info">
                <strong>Goal:</strong> Jump across platforms and meet other characters!
            </div>
            <div class="info" id="score">Score: 0</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Disable image smoothing for crisp pixel art
        ctx.imageSmoothingEnabled = false;
        ctx.mozImageSmoothingEnabled = false;
        ctx.webkitImageSmoothingEnabled = false;
        ctx.msImageSmoothingEnabled = false;

        // Game state
        const game = {
            score: 0,
            frame: 0,
            keys: {},
            characters: [],
            player: null,
            assetsLoaded: 0,
            totalAssets: 0,
            gameStarted: false,
            gravity: 0.5,
            platforms: []
        };

        // Platform class
        class Platform {
            constructor(x, y, width, height, color = '#8B4513') {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.color = color;
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                // Add some detail
                ctx.strokeStyle = '#654321';
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x, this.y, this.width, this.height);
            }

            checkCollision(character) {
                return character.x < this.x + this.width &&
                       character.x + character.width > this.x &&
                       character.y < this.y + this.height &&
                       character.y + character.height > this.y;
            }
        }

        // Sprite class to handle 2-frame directional animations
        // Frame 0 (top half) = Left movement
        // Frame 1 (bottom half) = Right movement
        class Character {
            constructor(imagePath, x, y, isPlayer = false) {
                this.x = x;
                this.y = y;
                this.scale = 4; // Scale up the tiny sprites
                this.width = 64; // Will be adjusted when image loads
                this.height = 64; // Will be adjusted when image loads
                this.velocityX = 0;
                this.velocityY = 0;
                this.speed = isPlayer ? 5 : 2;
                this.jumpPower = isPlayer ? -12 : -10;
                this.isPlayer = isPlayer;
                this.onGround = false;
                this.image = new Image();
                this.image.src = imagePath;
                this.loaded = false;
                this.currentFrame = 1; // Start facing right
                this.facingRight = true; // Track which direction we're facing
                this.name = imagePath.replace('.png', '');

                // Movement for NPCs
                if (!isPlayer) {
                    this.moveDirection = Math.random() > 0.5 ? 1 : -1;
                    this.jumpTimer = Math.floor(Math.random() * 60) + 30;
                    // Set initial frame based on initial direction
                    this.facingRight = this.moveDirection > 0;
                    this.currentFrame = this.facingRight ? 1 : 0;
                }

                game.totalAssets++;

                this.image.onload = () => {
                    this.loaded = true;
                    game.assetsLoaded++;
                    // Image is split horizontally: top half is frame 0, bottom half is frame 1
                    this.frameHeight = this.image.height / 2;
                    this.frameWidth = this.image.width;
                    // Adjust character size based on actual sprite size
                    this.width = this.frameWidth * this.scale;
                    this.height = this.frameHeight * this.scale;
                    console.log(`Loaded ${imagePath}: ${this.frameWidth}x${this.frameHeight} (scaled to ${this.width}x${this.height})`);

                    if (game.assetsLoaded === game.totalAssets) {
                        console.log('All assets loaded!');
                        game.gameStarted = true;
                    }
                };

                this.image.onerror = () => {
                    console.error(`Failed to load image: ${imagePath}`);
                    game.assetsLoaded++;
                    if (game.assetsLoaded === game.totalAssets) {
                        game.gameStarted = true;
                    }
                };
            }

            update() {
                // Apply gravity
                this.velocityY += game.gravity;

                if (this.isPlayer) {
                    // Player horizontal movement
                    this.velocityX = 0;

                    if (game.keys['ArrowLeft'] || game.keys['a']) {
                        this.velocityX = -this.speed;
                        this.facingRight = false;
                        this.currentFrame = 0; // Top frame for left movement
                    }
                    if (game.keys['ArrowRight'] || game.keys['d']) {
                        this.velocityX = this.speed;
                        this.facingRight = true;
                        this.currentFrame = 1; // Bottom frame for right movement
                    }

                    // Jump
                    if ((game.keys['ArrowUp'] || game.keys['w'] || game.keys[' ']) && this.onGround) {
                        this.velocityY = this.jumpPower;
                        this.onGround = false;
                    }
                } else {
                    // NPC movement
                    this.velocityX = this.moveDirection * this.speed;

                    // Update frame based on movement direction
                    if (this.moveDirection < 0) {
                        this.facingRight = false;
                        this.currentFrame = 0; // Top frame for left movement
                    } else {
                        this.facingRight = true;
                        this.currentFrame = 1; // Bottom frame for right movement
                    }

                    // Random jumping
                    this.jumpTimer--;
                    if (this.jumpTimer <= 0 && this.onGround) {
                        this.velocityY = this.jumpPower;
                        this.jumpTimer = Math.floor(Math.random() * 120) + 60;
                    }

                    // Change direction at edges
                    if (this.x < 0 || this.x > canvas.width - this.width) {
                        this.moveDirection *= -1;
                    }
                }

                // Apply velocity
                this.x += this.velocityX;
                this.y += this.velocityY;

                // Reset ground status
                this.onGround = false;

                // Platform collision detection
                for (let platform of game.platforms) {
                    if (this.checkPlatformCollision(platform)) {
                        // Landing on top of platform
                        if (this.velocityY > 0 && this.y + this.height - this.velocityY <= platform.y + 5) {
                            this.y = platform.y - this.height;
                            this.velocityY = 0;
                            this.onGround = true;
                        }
                        // Hitting bottom of platform
                        else if (this.velocityY < 0 && this.y - this.velocityY >= platform.y + platform.height) {
                            this.y = platform.y + platform.height;
                            this.velocityY = 0;
                        }
                        // Side collision
                        else {
                            if (this.velocityX > 0) {
                                this.x = platform.x - this.width;
                            } else if (this.velocityX < 0) {
                                this.x = platform.x + platform.width;
                            }
                            this.velocityX = 0;
                            if (!this.isPlayer) {
                                this.moveDirection *= -1;
                            }
                        }
                    }
                }

                // Keep in bounds horizontally
                if (this.x < 0) {
                    this.x = 0;
                    if (!this.isPlayer) this.moveDirection = 1;
                }
                if (this.x > canvas.width - this.width) {
                    this.x = canvas.width - this.width;
                    if (!this.isPlayer) this.moveDirection = -1;
                }

                // Terminal velocity
                if (this.velocityY > 15) {
                    this.velocityY = 15;
                }
            }

            checkPlatformCollision(platform) {
                return this.x < platform.x + platform.width &&
                       this.x + this.width > platform.x &&
                       this.y < platform.y + platform.height &&
                       this.y + this.height > platform.y;
            }

            draw() {
                if (!this.loaded) return;

                // Save context state
                ctx.save();

                // Draw the current frame (split horizontally)
                ctx.drawImage(
                    this.image,
                    0, // source x
                    this.currentFrame * this.frameHeight, // source y (0 for frame 0, frameHeight for frame 1)
                    this.frameWidth, // source width
                    this.frameHeight, // source height
                    Math.floor(this.x), // destination x
                    Math.floor(this.y), // destination y
                    this.width, // destination width (scaled)
                    this.height // destination height (scaled)
                );

                // Draw name tag for player
                if (this.isPlayer) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(this.x, this.y - 20, this.width, 15);
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('PLAYER', this.x + this.width / 2, this.y - 8);
                }

                ctx.restore();
            }

            checkCollision(other) {
                return this.x < other.x + other.width &&
                       this.x + this.width > other.x &&
                       this.y < other.y + other.height &&
                       this.y + this.height > other.y;
            }
        }

        // Initialize game
        function init() {
            // Create platforms for the platformer level
            // Ground
            game.platforms.push(new Platform(0, 550, canvas.width, 50, '#2d5016'));

            // Various platforms at different heights
            game.platforms.push(new Platform(100, 450, 150, 20, '#8B4513'));
            game.platforms.push(new Platform(300, 380, 120, 20, '#8B4513'));
            game.platforms.push(new Platform(500, 320, 150, 20, '#8B4513'));
            game.platforms.push(new Platform(150, 260, 100, 20, '#8B4513'));
            game.platforms.push(new Platform(400, 200, 120, 20, '#8B4513'));
            game.platforms.push(new Platform(650, 450, 130, 20, '#8B4513'));
            game.platforms.push(new Platform(50, 150, 100, 20, '#8B4513'));
            game.platforms.push(new Platform(600, 150, 150, 20, '#8B4513'));

            // Create player on the ground
            game.player = new Character('player.png', 100, 480, true);
            game.characters.push(game.player);

            // Create NPCs with different sprites on various platforms
            const npcSprites = [
                'npc1.png',
                'npc2.png',
                'sprite.png',
                'sprite2.png',
                'sprite3.png',
                'sprite4.png',
                'sprite5.png',
                'dinggusen.png',
                'gressgusen.png',
                'lanternegusen.png',
                'lunagusen.png',
                'spaghettigusen.png',
                'wirelessgusen.png',
                'generatorgusen.png'
            ];

            // Place NPCs on different platforms
            const npcPositions = [
                { x: 120, y: 380 },  // On first platform
                { x: 320, y: 310 },  // On second platform
                { x: 520, y: 250 },  // On third platform
                { x: 170, y: 190 },  // On fourth platform
                { x: 420, y: 130 },  // On fifth platform
                { x: 670, y: 380 },  // On sixth platform
            ];

            for (let i = 0; i < 6; i++) {
                const sprite = npcSprites[i % npcSprites.length];
                const pos = npcPositions[i];
                game.characters.push(new Character(sprite, pos.x, pos.y, false));
            }

            console.log(`Platformer initialized with ${game.characters.length} characters and ${game.platforms.length} platforms`);
            console.log(`Loading ${game.totalAssets} assets...`);
        }

        // Game loop
        function gameLoop() {
            // Clear canvas
            ctx.fillStyle = '#87ceeb';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Show loading screen if assets aren't loaded
            if (!game.gameStarted) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'white';
                ctx.font = 'bold 32px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Loading...', canvas.width / 2, canvas.height / 2 - 20);
                ctx.font = '20px Arial';
                ctx.fillText(`${game.assetsLoaded} / ${game.totalAssets} sprites loaded`, canvas.width / 2, canvas.height / 2 + 20);
                requestAnimationFrame(gameLoop);
                return;
            }

            // Draw clouds
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.beginPath();
            ctx.arc(100, 80, 30, 0, Math.PI * 2);
            ctx.arc(130, 80, 40, 0, Math.PI * 2);
            ctx.arc(160, 80, 30, 0, Math.PI * 2);
            ctx.fill();

            ctx.beginPath();
            ctx.arc(500, 120, 35, 0, Math.PI * 2);
            ctx.arc(535, 120, 45, 0, Math.PI * 2);
            ctx.arc(575, 120, 35, 0, Math.PI * 2);
            ctx.fill();

            // Draw platforms
            game.platforms.forEach(platform => {
                platform.draw();
            });

            // Update all characters
            game.characters.forEach(char => {
                char.update();
            });

            // Check collisions between player and NPCs
            if (game.player) {
                game.characters.forEach(char => {
                    if (!char.isPlayer && char.loaded && game.player.checkCollision(char)) {
                        // Simple collision response - bounce back
                        if (game.frame % 60 === 0) {
                            game.score += 10;
                            document.getElementById('score').textContent = 'Score: ' + game.score;
                        }
                    }
                });
            }

            // Draw all characters
            game.characters.forEach(char => {
                char.draw();
            });

            // Draw UI
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(10, 10, 250, 50);
            ctx.fillStyle = 'white';
            ctx.font = '16px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('Characters: ' + game.characters.length, 20, 30);
            ctx.fillText('Loaded: ' + game.characters.filter(c => c.loaded).length, 20, 50);

            game.frame++;
            requestAnimationFrame(gameLoop);
        }

        // Event listeners
        window.addEventListener('keydown', (e) => {
            game.keys[e.key] = true;
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
                e.preventDefault();
            }
        });

        window.addEventListener('keyup', (e) => {
            game.keys[e.key] = false;
        });

        // Start game
        init();
        gameLoop();
    </script>
</body>
</html>
